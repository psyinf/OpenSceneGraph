/* -*-c++-*- OpenSceneGraph - Copyright (C) Cedric Pinson
 *
 * This application is open source and may be redistributed and/or modified
 * freely and without restriction, both in commercial and non commercial
 * applications, as long as this copyright notice is maintained.
 *
 * This application is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
*/

#ifndef TANGENT_SPACE_VISITOR
#define TANGENT_SPACE_VISITOR

#define TANGENT_ATTRIBUTE_INDEX 20

#include <osgUtil/TangentSpaceGenerator>
#include <osg/ValueObject> // {get,set}UserValue
#include <osg/Array>

#include "GeometryUniqueVisitor"


// we will store only tangent and rebuilt tangent2 in the vertex shader
// http://www.terathon.com/code/tangent.html

class TangentSpaceVisitor : public GeometryUniqueVisitor
{
public:
    TangentSpaceVisitor(int textureUnit = 0):
        GeometryUniqueVisitor("TangentSpaceVisitor"),
        _textureUnit(textureUnit)
    {}

    void process(osgAnimation::MorphGeometry& morphGeometry) {
        process(static_cast<osg::Geometry&>(morphGeometry));

        osgAnimation::MorphGeometry::MorphTargetList& targets = morphGeometry.getMorphTargetList();
        for(osgAnimation::MorphGeometry::MorphTargetList::iterator target = targets.begin() ; target != targets.end() ; ++ target) {
            osg::Geometry* geometry = target->getGeometry();
            bool useParentMorphTexCoord = geometry->getTexCoordArrayList().empty();

            if(useParentMorphTexCoord) {
                // tangent space require tex coords; in case a target has no tex coords, we try to
                // bind the parent geometry tex coords
                geometry->setTexCoordArrayList(morphGeometry.getTexCoordArrayList());
            }

            process(*geometry);

            if(useParentMorphTexCoord) {
                // drop parent tex coords after tangent space computation
                geometry->setTexCoordArrayList(osg::Geometry::ArrayList());
            }
        }
    }

    void process(osg::Geometry& geom) {
        // We don't have to recompute the tangent space if we already have the data
        int tangentIndex = -1;
        if (geom.getUserValue(std::string("tangent"), tangentIndex) && tangentIndex != -1)
        {
            if(geom.getVertexAttribArray(tangentIndex)) {
                OSG_INFO << "[TangentSpaceVisitor::apply] Geometry '" << geom.getName()
                        << "' The tangent space is not recomputed as it was given within the original file" << std::endl;
                geom.getVertexAttribArray(tangentIndex)->setUserValue("tangent", true);
                return;
            }
        }

        if (!geom.getTexCoordArray(_textureUnit)){
            int texUnit = 0;
            bool found = false;
            while(texUnit < 32){
                if (_textureUnit != texUnit && geom.getTexCoordArray(texUnit)){
                    _textureUnit = texUnit;
                    found = true;
                    break;
                }
                texUnit++;
            }
            if (!found)
                return;
        }

        osg::ref_ptr<osgUtil::TangentSpaceGenerator> generator = new osgUtil::TangentSpaceGenerator;
        generator->generate(&geom, _textureUnit);

        // keep original normal array
        if (!geom.getNormalArray()) {
            if (generator->getNormalArray()) {
                osg::Vec3Array* vec3Normals = new osg::Vec3Array();
                osg::Vec4Array* vec4Normals = generator->getNormalArray();
                for (unsigned int i = 0; i < vec4Normals->size(); i++) {
                    osg::Vec3 n = osg::Vec3((*vec4Normals)[i][0],
                                            (*vec4Normals)[i][1],
                                            (*vec4Normals)[i][2]);
                    vec3Normals->push_back(n);
                }
                geom.setNormalArray(vec3Normals, osg::Array::BIND_PER_VERTEX);
            }
        }

        if (generator->getTangentArray()) {
            osg::Vec4Array* normal = generator->getNormalArray();
            osg::Vec4Array* tangent = generator->getTangentArray();
            osg::Vec4Array* tangent2 = generator->getBinormalArray();
            osg::Vec4Array* finalTangent = osg::clone(generator->getTangentArray(), osg::CopyOp::DEEP_COPY_ALL);
            for (unsigned int i = 0; i < tangent->size(); i++) {
                osg::Vec3 n = osg::Vec3((*normal)[i][0],
                                        (*normal)[i][1],
                                        (*normal)[i][2]);
                osg::Vec3 t = osg::Vec3((*tangent)[i][0],
                                        (*tangent)[i][1],
                                        (*tangent)[i][2]);
                osg::Vec3 t2 = osg::Vec3((*tangent2)[i][0],
                                         (*tangent2)[i][1],
                                         (*tangent2)[i][2]);

                // Gram-Schmidt orthogonalize
                osg::Vec3 t3 = (t - n * (n * t));
                t3.normalize();
                (*finalTangent)[i] = osg::Vec4(t3, 0.0);

                // Calculate handedness
                (*finalTangent)[i][3] = (((n ^ t) * t2) < 0.0) ? -1.0 : 1.0;
                // The bitangent vector B is then given by B = (N × T) · Tw
            }
            finalTangent->setUserValue("tangent", true);
            tangentIndex = (tangentIndex >= 0 ? tangentIndex : geom.getNumVertexAttribArrays()) ;
            geom.setVertexAttribArray(tangentIndex, finalTangent, osg::Array::BIND_PER_VERTEX);
        }
    }

protected:
    int _textureUnit;
};

#endif
